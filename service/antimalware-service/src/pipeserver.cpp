#include "pipeserver.h"

#include <AccCtrl.h>
#include <AclAPI.h>
#include <strsafe.h>
#include <winnt.h>

#include "logger.h"

namespace samlw {
namespace pipe_server {
int RunNamedPipeServer(VOID) {
    auto logger = Logger::GetInstance();
    BOOL fConnected = FALSE;
    DWORD dwThreadId = 0;
    HANDLE hPipe = INVALID_HANDLE_VALUE, hThread = NULL;
    LPCTSTR lpszPipename = PIPE_PATH;

    // The main loop creates an instance of the named pipe and
    // then waits for a client to connect to it. When the client
    // connects, a thread is created to handle communications
    // with that client, and this loop is free to wait for the
    // next client connect request. It is an infinite loop.

    for (;;) {
        // _tprintf(TEXT("\nPipe Server: Main thread awaiting client connection on %s\n"),
        //  lpszPipename);
        PSID pEveryoneSID = NULL;
        PACL pACL = NULL;
        PSECURITY_DESCRIPTOR pSD = {0};
        // An array of EXPLICIT_ACCESS structure
        EXPLICIT_ACCESS ea[2];
        SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        SECURITY_ATTRIBUTES sa = {0};
        LONG lRes;
        HKEY hkSub = NULL;

        // Create a well-known SID for the Everyone group.
        if (!AllocateAndInitializeSid(&SIDAuthWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0,
                                      0, &pEveryoneSID))

        {
        }
        ZeroMemory(&ea, 2 * sizeof(EXPLICIT_ACCESS));
        ea[0].grfAccessPermissions = KEY_READ;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName = (LPTSTR)pEveryoneSID;
        // Initialize a security descriptor.

        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (pSD == NULL) {
        }

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
        }

        // Add the ACL to the security descriptor.
        if (!SetSecurityDescriptorDacl(pSD,
                                       TRUE,  // bDaclPresent flag
                                       pACL,
                                       FALSE))  // not a default DACL
        {
        }

        // Initialize a security attributes structure.
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;
        // Use the security attributes to set the security descriptor
        // when you create a registry key.
        // If successful
        logger->LogMessage("\nPipe Server: Main thread awaiting client connection...\n");
        hPipe = CreateNamedPipeW(lpszPipename,                // pipe name
                                 PIPE_ACCESS_DUPLEX,          // read/write access
                                 PIPE_TYPE_MESSAGE |          // message type pipe
                                     PIPE_READMODE_MESSAGE |  // message-read mode
                                     PIPE_WAIT,               // blocking mode
                                 PIPE_UNLIMITED_INSTANCES,    // max. instances
                                 BUFSIZE,                     // output buffer size
                                 BUFSIZE,                     // input buffer size
                                 0,                           // client time-out
                                 &sa);                        // default security attribute
        // Применяем Security Descriptor к каналу

        if (hPipe == INVALID_HANDLE_VALUE) {
            logger->LogMessage("CreateNamedPipe failed, GLE=" +
                               std::to_string(GetLastError()) + std::string("\n"));
            // _tprintf(TEXT("CreateNamedPipe failed, GLE=%d.\n"), GetLastError());
            return -1;
        }

        // Wait for the client to connect; if it succeeds,
        // the function returns a nonzero value. If the function
        // returns zero, GetLastError returns ERROR_PIPE_CONNECTED.

        fConnected =
            ConnectNamedPipe(hPipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);

        if (fConnected) {
            logger->LogMessage("Client connected, creating a processing thread.\n");

            // Create a thread for this client.
            hThread = CreateThread(NULL,                  // no security attribute
                                   0,                     // default stack size
                                   impl::InstanceThread,  // thread proc
                                   (LPVOID)hPipe,         // thread parameter
                                   0,                     // not suspended
                                   &dwThreadId);          // returns thread ID

            if (hThread == NULL) {
                logger->LogMessage("CreateThread failed, GLE=" +
                                   std::to_string(GetLastError()) + std::string("\n"));
                // _tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError());
                return -1;
            } else
                CloseHandle(hThread);
        } else
            // The client could not connect, so close the pipe.
            CloseHandle(hPipe);
    }

    return 0;
}

namespace impl {
DWORD WINAPI InstanceThread(LPVOID lpvParam)
// This routine is a thread processing function to read from and reply to a client
// via the open pipe connection passed from the main loop. Note this allows
// the main loop to continue executing, potentially creating more threads of
// of this procedure to run concurrently, depending on the number of incoming
// client connections.
{
    auto logger = Logger::GetInstance();

    HANDLE hHeap = GetProcessHeap();
    TCHAR* pchRequest = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE * sizeof(TCHAR));
    TCHAR* pchReply = (TCHAR*)HeapAlloc(hHeap, 0, BUFSIZE * sizeof(TCHAR));

    DWORD cbBytesRead = 0, cbReplyBytes = 0, cbWritten = 0;
    BOOL fSuccess = FALSE;
    HANDLE hPipe = NULL;

    // Do some extra error checking since the app will keep running even if this
    // thread fails.

    if (lpvParam == NULL) {
        logger->LogMessage(
            std::string("\nERROR - Pipe Server Failure:\n   InstanceThread got an unexpected "
                        "NULL value in lpvParam.\n   InstanceThread exitting.\n"),
            EVENTLOG_ERROR_TYPE);
        // printf("\nERROR - Pipe Server Failure:\n");
        // printf("   InstanceThread got an unexpected NULL value in lpvParam.\n");
        // printf("   InstanceThread exitting.\n");
        if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
        if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
        return (DWORD)-1;
    }

    if (pchRequest == NULL) {
        logger->LogMessage(
            std::string("\nERROR - Pipe Server Failure:\n   InstanceThread got an unexpected "
                        "NULL value in lpvParam.\n   InstanceThread exitting.\n"),
            EVENTLOG_ERROR_TYPE);
        // printf("\nERROR - Pipe Server Failure:\n");
        // printf("   InstanceThread got an unexpected NULL heap allocation.\n");
        // printf("   InstanceThread exitting.\n");
        if (pchReply != NULL) HeapFree(hHeap, 0, pchReply);
        return (DWORD)-1;
    }

    if (pchReply == NULL) {
        logger->LogMessage(
            std::string("\nERROR - Pipe Server Failure:\n   InstanceThread got an unexpected "
                        "NULL value in lpvParam.\n   InstanceThread exitting.\n"),
            EVENTLOG_ERROR_TYPE);
        // printf("\nERROR - Pipe Server Failure:\n");
        // printf("   InstanceThread got an unexpected NULL heap allocation.\n");
        // printf("   InstanceThread exitting.\n");
        if (pchRequest != NULL) HeapFree(hHeap, 0, pchRequest);
        return (DWORD)-1;
    }

    // Print verbose messages. In production code, this should be for debugging only.
    logger->LogMessage("InstanceThread created, receiving and processing messages.\n");
    // printf("InstanceThread created, receiving and processing messages.\n");

    // The thread's parameter is a handle to a pipe object instance.

    hPipe = (HANDLE)lpvParam;

    // Loop until done reading
    while (1) {
        // Read client requests from the pipe. This simplistic code only allows messages
        // up to BUFSIZE characters in length.
        fSuccess = ReadFile(hPipe,                    // handle to pipe
                            pchRequest,               // buffer to receive data
                            BUFSIZE * sizeof(TCHAR),  // size of buffer
                            &cbBytesRead,             // number of bytes read
                            NULL);                    // not overlapped I/O

        if (!fSuccess || cbBytesRead == 0) {
            if (GetLastError() == ERROR_BROKEN_PIPE) {
                logger->LogMessage("InstanceThread: client disconnected.\n");
                // _tprintf(TEXT("InstanceThread: client disconnected.\n"));
            } else {
                logger->LogMessage("InstanceThread ReadFile failed, GLE=" +
                                   std::to_string(GetLastError()) + std::string("\n"));
                // _tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"),
                // GetLastError());
            }
            break;
        }

        // Process the incoming message.
        GetAnswerToRequest(pchRequest, pchReply, &cbReplyBytes);

        // Write the reply to the pipe.
        fSuccess = WriteFile(hPipe,         // handle to pipe
                             pchReply,      // buffer to write from
                             cbReplyBytes,  // number of bytes to write
                             &cbWritten,    // number of bytes written
                             NULL);         // not overlapped I/O

        if (!fSuccess || cbReplyBytes != cbWritten) {
            logger->LogMessage("InstanceThread WriteFile failed, GLE=" +
                               std::to_string(GetLastError()) + std::string("\n"));
            // _tprintf(TEXT("InstanceThread WriteFile failed, GLE=%d.\n"), GetLastError());
            break;
        }
    }

    // Flush the pipe to allow the client to read the pipe's contents
    // before disconnecting. Then disconnect the pipe, and close the
    // handle to this pipe instance.

    FlushFileBuffers(hPipe);
    DisconnectNamedPipe(hPipe);
    CloseHandle(hPipe);

    HeapFree(hHeap, 0, pchRequest);
    HeapFree(hHeap, 0, pchReply);

    logger->LogMessage("InstanceThread exiting.\n");
    // printf("InstanceThread exiting.\n");
    return 1;
}

VOID GetAnswerToRequest(LPTSTR pchRequest, LPTSTR pchReply, LPDWORD pchBytes)
// This routine is a simple function to print the client request to the console
// and populate the reply buffer with a default data string. This is where you
// would put the actual client request processing code that runs in the context
// of an instance thread. Keep in mind the main thread will continue to wait for
// and receive other client connections while the instance thread is working.
{
    static int counter{0};
    auto logger = Logger::GetInstance();

    auto converted_message = std::wstring(pchRequest);
    // _tprintf(TEXT("Client Request String:\"%s\"\n"), pchRequest);
    // logger->LogMessage(std::wstring(L"Client Request String:\"") + pchRequest +
    //    std::wstring(L"\"\n")); НЕ РАБОТАЕТ!!!?????
    logger->LogMessage("New client request.");
    wprintf(converted_message.c_str());
    wprintf(L"\n");

    // Check the outgoing message to make sure it's not too long for the buffer.
    if (converted_message == std::wstring(L"+"))
        counter++;
    else if (converted_message == std::wstring(L"-"))
        counter--;

    std::wstring res = L"counter=" + std::to_wstring(counter);
    if (FAILED(StringCchCopy(pchReply, BUFSIZE, res.c_str()))) {
        *pchBytes = 0;
        pchReply[0] = 0;
        logger->LogMessage("StringCchCopy failed, no outgoing message.\n",
                           EVENTLOG_ERROR_TYPE);
        // printf("StringCchCopy failed, no outgoing message.\n");
        return;
    }
    *pchBytes = (lstrlen(pchReply) + 1) * sizeof(TCHAR);
}
}  // namespace impl
}  // namespace pipe_server
}  // namespace samlw