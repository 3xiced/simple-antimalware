#include "mainhandler.h"

#include <Shlwapi.h>
#include <sddl.h>

#include <iostream>
#include <string>
#include <thread>

#include "logger.h"
#include "pipeserver.h"
#include "stdafx.h"

namespace {
inline int CreateAppProcessFromPath(WCHAR command_line[], HANDLE user_token) noexcept {
    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo{sizeof(startupInfo)};

    SECURITY_ATTRIBUTES processSecurityAttributes{};
    processSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    processSecurityAttributes.bInheritHandle = TRUE;

    SECURITY_ATTRIBUTES threadSecurityAttributes{};
    threadSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    threadSecurityAttributes.bInheritHandle = TRUE;

    WCHAR sddl[] = L"O:SYG:SYD:";
    PSECURITY_DESCRIPTOR psd = nullptr;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION_1, &psd,
                                                              nullptr))
        return GetLastError();

    processSecurityAttributes.lpSecurityDescriptor = psd;
    threadSecurityAttributes.lpSecurityDescriptor = psd;

    if (!CreateProcessAsUserW(user_token, NULL, command_line, &processSecurityAttributes,
                              &threadSecurityAttributes, FALSE, NORMAL_PRIORITY_CLASS, NULL,
                              NULL, &startupInfo, &processInfo))
        return GetLastError();

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    return NO_ERROR;
}

inline void GetAppExecutablePath(wchar_t *out) {
    GetModuleFileName(NULL, out, 260);
    PathRemoveFileSpec(out);
    PathAppend(out, L"app.exe");
}

int RunAppInSession(DWORD wts_sess) noexcept {
    HANDLE user_token;
    if (!WTSQueryUserToken(wts_sess, &user_token)) return GetLastError();

    wchar_t path[_MAX_PATH];
    GetAppExecutablePath(path);
    auto create_proc_res = CreateAppProcessFromPath(path, user_token);
    CloseHandle(user_token);

    return create_proc_res;
};

}  // namespace

namespace samlw {
/// @brief Starts client in specific session
/// @param session_id DWORD sessiond
void MainHandler::OpenClient(DWORD session_id) const noexcept {
    logger_->LogMessage("Running app in session = " + std::to_string(session_id));
    if (auto res_code = RunAppInSession(session_id); res_code != 0)
        logger_->LogMessage("RunAppInSession failed: " + std::to_string(res_code),
                            EVENTLOG_ERROR_TYPE);
}

/// @brief Starts client in all existing sessions
void MainHandler::OpenClient() const noexcept {
    PWTS_SESSION_INFO wts_sessions;
    DWORD sessions_cnt;
    if (!WTSEnumerateSessionsW(WTS_CURRENT_SERVER_HANDLE, 0, 1, &wts_sessions, &sessions_cnt))
        return logger_->LogMessage("Could not iterate over WTS sessions...",
                                   EVENTLOG_ERROR_TYPE);
    logger_->LogMessage("Found sessions ammount = " + std::to_string(sessions_cnt));

    for (DWORD i = 0; i < sessions_cnt; i++) {
        DWORD wts_sess = wts_sessions[i].SessionId;
        if (wts_sess == 0) continue;

        OpenClient(wts_sess);
    }
}

void MainHandler::CreateNamedPipeServer() {
    static std::thread pipe_server_task{std::thread(pipe_server::RunNamedPipeServer)};
    if (!pipe_server_task.joinable()) return;

    pipe_server_task.detach();
    logger_->LogMessage("Named pipe server started successfully");
}
}  // namespace samlw
