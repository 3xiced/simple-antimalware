#include "mainhandler.h"

#include <Shlwapi.h>
#include <sddl.h>

#include <codecvt>
#include <fstream>
#include <iostream>
#include <string>
#include <thread>
#include <vector>
#include <xlocbuf>

#include "logger.h"
#include "pipeserver.h"
#include "stdafx.h"

#pragma warning(disable : 4996)

namespace {
inline int CreateAppProcessFromPath(WCHAR command_line[], HANDLE user_token) noexcept {
    PROCESS_INFORMATION processInfo;
    STARTUPINFO startupInfo{sizeof(startupInfo)};

    SECURITY_ATTRIBUTES processSecurityAttributes{};
    processSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    processSecurityAttributes.bInheritHandle = TRUE;

    SECURITY_ATTRIBUTES threadSecurityAttributes{};
    threadSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    threadSecurityAttributes.bInheritHandle = TRUE;

    WCHAR sddl[] = L"O:SYG:SYD:";
    PSECURITY_DESCRIPTOR psd = nullptr;

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION_1, &psd,
                                                              nullptr))
        return GetLastError();

    processSecurityAttributes.lpSecurityDescriptor = psd;
    threadSecurityAttributes.lpSecurityDescriptor = psd;

    if (!CreateProcessAsUserW(user_token, NULL, command_line, &processSecurityAttributes,
                              &threadSecurityAttributes, FALSE, NORMAL_PRIORITY_CLASS, NULL,
                              NULL, &startupInfo, &processInfo))
        return GetLastError();

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    return NO_ERROR;
}

inline void GetAppExecutablePath(wchar_t* out) {
    GetModuleFileName(NULL, out, 260);
    PathRemoveFileSpec(out);
}

int RunAppInSession(DWORD wts_sess) noexcept {
    HANDLE user_token;
    if (!WTSQueryUserToken(wts_sess, &user_token)) return GetLastError();

    wchar_t path[_MAX_PATH];
    GetAppExecutablePath(path);
    PathAppend(path, L"app.exe");
    auto create_proc_res = CreateAppProcessFromPath(path, user_token);
    CloseHandle(user_token);

    return create_proc_res;
};

size_t split(const std::string& txt, std::vector<std::string>& strs, char ch) {
    size_t pos = txt.find(ch);
    size_t initialPos = 0;
    strs.clear();

    // Decompose statement
    while (pos != std::string::npos) {
        strs.push_back(txt.substr(initialPos, pos - initialPos));
        initialPos = pos + 1;

        pos = txt.find(ch, initialPos);
    }

    // Add the last one
    strs.push_back(txt.substr(initialPos, (std::min)(pos, txt.size()) - initialPos + 1));

    return strs.size();
}
}  // namespace

namespace samlw {
/// @brief Starts client in specific session
/// @param session_id DWORD sessiond
void MainHandler::OpenClient(DWORD session_id) const noexcept {
    logger_->LogMessage("Running app in session = " + std::to_string(session_id));
    if (auto res_code = RunAppInSession(session_id); res_code != 0)
        logger_->LogMessage("RunAppInSession failed: " + std::to_string(res_code),
                            EVENTLOG_ERROR_TYPE);
}

/// @brief Starts client in all existing sessions
void MainHandler::OpenClient() const noexcept {
    PWTS_SESSION_INFO wts_sessions;
    DWORD sessions_cnt;
    if (!WTSEnumerateSessionsW(WTS_CURRENT_SERVER_HANDLE, 0, 1, &wts_sessions, &sessions_cnt))
        return logger_->LogMessage("Could not iterate over WTS sessions...",
                                   EVENTLOG_ERROR_TYPE);
    logger_->LogMessage("Found sessions ammount = " + std::to_string(sessions_cnt));

    for (DWORD i = 0; i < sessions_cnt; i++) {
        DWORD wts_sess = wts_sessions[i].SessionId;
        if (wts_sess == 0) continue;

        OpenClient(wts_sess);
    }
}

void MainHandler::CreateNamedPipeServer() {
    static std::thread pipe_server_task{std::thread(pipe_server::RunNamedPipeServer)};
    if (!pipe_server_task.joinable()) return;

    pipe_server_task.detach();
    logger_->LogMessage("Named pipe server started successfully");
}

void MainHandler::ScanFile(const wchar_t* file_path) {
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;

    std::ifstream file(converter.to_bytes(std::wstring(file_path)).c_str(), std::ios::binary);

    if (!file.is_open()) {
        logger_->LogMessage("Error opening file");
        return;
    }

    uint8_t byte;
    std::string s_sig = "";
    while (file >> std::noskipws >> byte) {
        s_sig.append(std::to_string(byte) + " ");
    }
    std::cout << "success file read" << std::endl;
    // std::cout << s_sig << std::endl;

    auto res = ac_->parse_text(s_sig);
    std::cout << res.size() << std::endl;

    file.close();
}

void MainHandler::LoadDatabase() noexcept {
    wchar_t path[_MAX_PATH];
    GetAppExecutablePath(path);
    PathAppend(path, L"examples\\signatures.bin");
    std::wcout << path;
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;

    std::ifstream file(converter.to_bytes(std::wstring(path)).c_str(), std::ios::binary);

    if (!file.is_open()) {
        logger_->LogMessage("Error opening file");
        return;
    }

    std::vector<std::string> patterns;
    uint8_t byte;
    std::string s_sig = "";
    if (file.is_open()) {
        std::string sa;
        // Read data from the file object and put it into a string.
        while (getline(file, sa)) {
            // Print the data of the string.
            std::vector<std::string> v;
            split(sa, v, ' ');

            std::string s_sig = "";
            for (auto byte : v) {
                uint8_t x = std::stoul(byte, nullptr, 16);
                // std::cout << std::to_string(x) + " ";
                s_sig.append(std::to_string(x) + " ");
            }
            patterns.push_back(s_sig);
            s_sig.clear();
        }

        // Close the file object.
        file.close();
    }

    ac_ = new aho_corasick::trie;
    for (auto sig : patterns) ac_->insert(sig);
}
}  // namespace samlw
