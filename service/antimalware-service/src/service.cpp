#include "service.h"

#include <iostream>

#include "event_ids.h"
#include "logger.h"
#include "stdafx.h"

namespace samlw {
Service::Service(PCWSTR pszServiceName, BOOL fCanStop, BOOL fCanShutdown,
                 BOOL fCanPauseContinue)
    : CServiceBase(pszServiceName, fCanStop, fCanShutdown, fCanPauseContinue, MSG_SVC_FAILURE,
                   CATEGORY_SERVICE) {
    is_stopping_ = FALSE;

    has_stopped_event_ = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (has_stopped_event_ == NULL) {
        throw GetLastError();
    }
}

void Service::OnStart(DWORD /* useleses */, PWSTR* /* useless */) {
    const wchar_t* wsConfigFullPath = SERVICE_CONFIG_FILE;
    bool bRunAsService = true;

    // Log a service start message to the Application log.
    WriteLogEntry(L"Simple Antimalware Service is starting...", EVENTLOG_INFORMATION_TYPE,
                  MSG_STARTUP, CATEGORY_SERVICE);

    if (m_argc > 1) {
        bRunAsService = (_wcsicmp(SERVICE_CMD, m_argv[1]) == 0);

        // Check if the config file was specified on the service command line
        if (m_argc > 2)  // the argument at 1 should be "run mode", so we start at 2
        {
            if (_wcsicmp(L"-config", m_argv[2]) == 0) {
                if (m_argc > 3) {
                    wsConfigFullPath = m_argv[3];
                } else {
                    throw std::exception("no configuration file name");
                }
            }
        }
    } else {
        WriteLogEntry(L"Simple Antimalware Service:\nNo run mode specified.",
                      EVENTLOG_ERROR_TYPE, MSG_STARTUP, CATEGORY_SERVICE);
        throw std::exception("no run mode specified");
    }

    try {
        // Here we would load configuration file
        // but instead we're just writing to event log the configuration file name
        std::wstring infoMsg =
            L"Simple Antimalware Service\n The service is pretending to read configuration "
            L"from ";
        infoMsg += wsConfigFullPath;
        WriteLogEntry(infoMsg.c_str(), EVENTLOG_INFORMATION_TYPE, MSG_STARTUP,
                      CATEGORY_SERVICE);
    } catch (std::exception const& e) {
        WCHAR wszMsg[MAX_PATH];

        _snwprintf_s(wszMsg, _countof(wszMsg), _TRUNCATE,
                     L"Simple Antimalware Service\nError reading configuration %S", e.what());

        WriteLogEntry(wszMsg, EVENTLOG_ERROR_TYPE, MSG_STARTUP, CATEGORY_SERVICE);
    }

    if (bRunAsService) {
        WriteLogEntry(L"Simple Antimalware Service will run as a service.",
                      EVENTLOG_INFORMATION_TYPE, MSG_STARTUP, CATEGORY_SERVICE);

        // Add the main service function for execution in a worker thread.
        if (!CreateThread(NULL, 0, ServiceRunner, this, 0, NULL)) {
            WriteLogEntry(L"Simple Antimalware Service couldn't create worker thread.",
                          EVENTLOG_ERROR_TYPE, MSG_STARTUP, CATEGORY_SERVICE);
        }
    } else {
        wprintf(L"Simple Antimalware Service is running as a regular process.\n");

        Service::ServiceRunner(this);
    }
}

void Service::Run() { OnStart(0, NULL); }

void Service::OnStop() {
    // Log a service stop message to the Application log.
    WriteLogEntry(L"Simple Antimalware Service is stopping", EVENTLOG_INFORMATION_TYPE,
                  MSG_SHUTDOWN, CATEGORY_SERVICE);

    // Indicate that the service is stopping and wait for the finish of the
    // main service function (ServiceWorkerThread).
    is_stopping_ = TRUE;

    if (WaitForSingleObject(has_stopped_event_, INFINITE) != WAIT_OBJECT_0) {
        throw GetLastError();
    }
}

DWORD __stdcall Service::ServiceRunner(void* self) {
    Service* pService = (Service*)self;
    auto logger = Logger::GetInstance(pService);
    pService->main_handler_ = MainHandler(logger);

    pService->WriteLogEntry(L"Simple Antimalware Service has started.",
                            EVENTLOG_INFORMATION_TYPE, MSG_STARTUP, CATEGORY_SERVICE);

    pService->main_handler_.OpenClient();
    pService->main_handler_.CreateNamedPipeServer();
    pService->main_handler_.CreateNamedPipeServer();
    // Periodically check if the service is stopping.
    for (bool once = true; !pService->is_stopping_; once = false) {
        Sleep(5000);
    }

    // Signal the stopped event.
    SetEvent(pService->has_stopped_event_);
    pService->WriteLogEntry(L"Simple Antimalware Service has stopped.",
                            EVENTLOG_INFORMATION_TYPE, MSG_SHUTDOWN, CATEGORY_SERVICE);

    return 0;
}

void Service::OnNewSession(DWORD dwSessionId) {
    auto logger = Logger::GetInstance();
    logger->LogMessage("Обнаружена новая сессия, запуск GUI... " +
                       std::to_string(dwSessionId));
    main_handler_.OpenClient(dwSessionId);
}
}  // namespace samlw
