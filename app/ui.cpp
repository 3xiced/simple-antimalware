#include "ui.h"

#include <Windows.h>
#include <stdio.h>
#include <winnt.h>

#include <codecvt>
#include <iostream>
#include <string>
#include <thread>
#include <xlocbuf>

#include "ImGuiFileDialog.h"
#include "imgui.h"

#pragma warning(disable : 4996)

namespace ui {
bool RenderUI() {
    ImGuiIO& io = ImGui::GetIO();

    static bool show_demo_window{true};
    if (show_demo_window) ImGui::ShowDemoWindow(&show_demo_window);
    static bool show_main_window{true};
    ImGui::Begin("Main window", &show_main_window);
    if (!show_main_window) {
        ImGui::End();
        return false;
    }
    // 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()!
    // You can browse its code to learn more about Dear ImGui!).

    static int counter{0};
    static std::string msg{""};
    if (ImGui::Button("Secure desktop")) {
        // HDESK old_desktop = GetThreadDesktop(GetCurrentThreadId());
        // HDESK new_desktop =
        //     CreateDesktopA("RandomDesktopName", NULL, NULL, 0, GENERIC_ALL, NULL);
        //// switching to the new desktop
        // SwitchDesktop(new_desktop);

        // SetThreadDesktop(new_desktop);
        // if (ImGui::Button("Add another modal..")) ImGui::OpenPopup("Stacked 2");

        //// Also demonstrate passing a bool* to BeginPopupModal(), this will create a
        //// regular close button which will close the popup. Note that the visibility state
        //// of popups is owned by imgui, so the input value of the bool actually doesn't
        //// matter here.
        // static bool unused_open{true};
        // while (unused_open) {
        //     ImGui::Begin("Window B", &unused_open);
        //     ImGui::Text("This is window B");
        //     ImGui::End();
        // }
        // Sleep(6000);

        //// if got here, the form is closed => switch back to the old desktop
        // SwitchDesktop(old_desktop);

        //// disposing the secure desktop since it's no longer needed
        // CloseDesktop(new_desktop);
    }
    if (ImGui::Button("Start scan")) {
        counter++;
        // At the top of your source file

        // Open the named pipe
        // Most of these parameters aren't very relevant for pipes.
        HANDLE pipe =
            CreateFileW(PIPE_PATH,
                        FILE_GENERIC_WRITE | FILE_GENERIC_READ,  // only need read access
                        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

        if (pipe == INVALID_HANDLE_VALUE) {
            // look up error code here using GetLastError()
            // return false;
            msg = std::string("Error code:") + std::to_string(GetLastError());
        }

        const wchar_t* data;
        data = (counter % 2 == 0) ? L"+" : L"-";

        DWORD numBytesWritten = 0;
        BOOL result1 =
            WriteFile(pipe,                                  // handle to our outbound pipe
                      data,                                  // data to send
                      (wcslen(data) + 1) * sizeof(wchar_t),  // length of data to send (bytes)
                      &numBytesWritten,  // will store actual amount of data sent
                      NULL               // not using overlapped IO
            );

        // The read operation will block until there is data to read
        wchar_t buffer[512];
        DWORD numBytesRead = 0;
        BOOL result =
            ReadFile(pipe,
                     buffer,                 // the data from the pipe will be put here
                     511 * sizeof(wchar_t),  // number of bytes allocated
                     &numBytesRead,          // this will store number of bytes actually read
                     NULL                    // not using overlapped IO
            );

        if (result) {
            buffer[numBytesRead / sizeof(wchar_t)] = '\0';  // null terminate the string
            std::wcout << "Number of bytes read: " << numBytesRead << std::endl;
            std::wcout << "Message: " << buffer << std::endl;
            using convert_typeX = std::codecvt_utf8<wchar_t>;
            std::wstring_convert<convert_typeX, wchar_t> converterX;

            msg = std::string(converterX.to_bytes(std::wstring(buffer)));
        } else {
            std::wcout << "Failed to read data from the pipe." << std::endl;
        }

        // Close our pipe handle
        CloseHandle(pipe);

        std::wcout << "Done." << std::endl;

    }  // Buttons return true when clicked (most widgets
       // return true when edited/activated)
    ImGui::SameLine();
    ImGui::Text("counter = %d", counter);
    ImGui::Text("Msg from server = %s", msg.c_str());

    static std::string filename{""};
    static std::string filendir{""};
    if (ImGui::Button("Check file for viruses")) {
        IGFD::FileDialogConfig config;
        config.path = ".";
        ImGuiFileDialog::Instance()->OpenDialog("Check file for virus", "Choose File", ".*",
                                                config);
    }
    if (ImGuiFileDialog::Instance()->Display("Check file for virus")) {
        if (ImGuiFileDialog::Instance()->IsOk()) {  // action if OK
            std::string filePathName = ImGuiFileDialog::Instance()->GetFilePathName();
            std::string filePath = ImGuiFileDialog::Instance()->GetCurrentPath();
            // action
            filename = filePathName;
            filendir = filePath;
        }

        // close
        ImGuiFileDialog::Instance()->Close();
    }
    ImGui::SameLine();
    ImGui::Text("Selected file name: %s", filename.c_str());
    ImGui::SameLine();
    ImGui::Text("Selected file dir: %s", filendir.c_str());

    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate,
                io.Framerate);
    ImGui::End();
    return true;
}
}  // namespace ui